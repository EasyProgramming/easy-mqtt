# 设计思路
使用消费者模式处理消息；使用调度任务定时消费数据库里面的消息；根据触发时间筛选消息；每次发送消息前，更新下一次的触发时间

消息表里面都是需要发送的消息，且qos>0

需要有一个异步任务执行表，用于处理异步处理逻辑，比如发送消息：SUBACK、UNSUBACK、PUBREL、PUBCOMP；比如处理接收到的消息


存疑：

    单机模式用sqlite；集群模式使用MySQL；性能瓶颈在MySQL；实现起来也简单
    raft用于广播
    服务端向客户端发送报文时，使用广播模式

处理接收到的消息，单独一个线程池，处理后即时发报文，然后等根据客户端维度的定时重试
    
定时重试时，按照客户端维度进行重试，这样可以保证消息的顺序性

重试时，如果客户端下面没有消息，则不再重试


# 问题汇总


# sqlite表设计
**客户端表**
- 客户端id
- 最后一次上线时间
- 创建时间

**主题过滤器表（topic filter）**
- 主题过滤器

**客户端关联的订阅过滤器表**
- 客户端id
- 订阅表达式
- 订阅时间
- qos

**收到的消息表**
- 收到的qos等级
- 主题
- 收到的消息id
- 消息来源客户端id
- 消息内容
- ``` 
  状态
      （
      qos=1 预备、插入到发送消息中后流转（已完成）；
      qos=2 预备、收到PUBREL报文，且插入到发送消息中后流转（已分发）（这里可以用本地队列做异步处理，可以减少netty核心线程的压力）、发送PUBCOMP消息后流转（已完成）
      
      状态为【已分发】，则发送PUBCOMP，发送成功后，流转为【已完成】
      ）
 
  ```
- 

**发送的消息表**
- 发送的qos等级
- 主题
- 发送的消息id
- 消息目的地客户端id
- 消息内容
- ```
  状态
  （
      qos=1 未确认、收到PUBACK报文后流转（已完成）
      qos=2 未确认、收到PUBREC报文后流转（已收到）、收到PUBCOMP报文后流转（已完成）
      
      状态为【未确认】，则发送PUBLISH报文
      状态为【已收到】，对应的逻辑为发送PUBREL报文
   ）
   ```
- 已发送次数（用于判断是否为重复消息）

**保留消息表（retain message）**
- 消息内容
- 收到的qos等级
- 主题

**异步任务表（async job）**
- 执行处理器（用于实现具体逻辑）
- 预计执行时间
- 已执行的次数
- 执行超时时间
- 执行状态
- 执行结果