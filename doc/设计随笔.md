# 设计思路
使用消费者模式处理消息；使用调度任务定时消费数据库里面的消息；根据触发时间筛选消息；每次发送消息前，更新下一次的触发时间

消息表里面都是需要发送的消息，且qos>0
# 问题汇总


# sqlite表设计
**客户端表**
- 客户端id
- 最后一次上线时间

**订阅过滤器表（topic filter）**


订阅表达式

**客户端关联的订阅过滤器表**
- 客户端id
- 订阅表达式
- 订阅时间

**收到的消息表**
- 收到的qos等级
- 主题
- 收到的消息id
- 消息来源客户端id
- 消息内容
- ``` 
  状态
      （
      qos=1 预备、插入到发送消息中后流转（已完成）；
      qos=2 预备、收到PUBREL报文，且插入到发送消息中后流转（已分发）、发送PUBCOMP消息后流转（已完成）
      
      状态为【已分发】，则发送PUBCOMP，发送成功后，流转为【已完成】
      ）
  ```




- 最近一次执行时间
- 已执行的次数
- 执行超时时间

**发送的消息表**
- 发送的qos等级
- 主题
- 发送的消息id
- 消息目的地客户端id
- 消息内容
- ```
  状态
  （
      qos=1 未确认、收到PUBACK报文后流转（已完成）
      qos=2 未确认、收到PUBREC报文后流转（已收到）、收到PUBCOMP报文后流转（已完成）
      
      状态为【未确认】，则发送PUBLISH报文
      状态为【已收到】，对应的逻辑为发送PUBREL报文
   ）
   ```
- 最近一次执行时间
- 已执行的次数
- 执行超时时间

**保留消息表（retain message）**
- 消息内容
- 收到的qos等级
- 主题

