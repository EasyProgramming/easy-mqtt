# 设计思路
使用消费者模式处理消息；使用调度任务定时消费数据库里面的消息；根据触发时间筛选消息；每次发送消息前，更新下一次的触发时间

消息表里面都是需要发送的消息，且qos>0

需要有一个异步任务执行表，用于处理异步处理逻辑，比如发送消息：SUBACK、UNSUBACK、PUBREL、PUBCOMP；比如处理接收到的消息


存疑：

    单机模式用sqlite；集群模式使用MySQL；性能瓶颈在MySQL；实现起来也简单
    raft用于广播
    服务端向客户端发送报文时，使用广播模式

处理接收到的消息，单独一个线程池，处理后即时发报文，发送消息，每次也发送之前未完成的消息，这样可以保证有序性

重试时，如果客户端下面没有消息，则不再重试

## 数据库初始化及升级
关于单机/集群模式下，数据库的初始化，以及后续的升级问题，如何处理？

新增元数据表，里面为key value形式，如果存在该表，则表示已完成初始化，再根据历史与当前版本号进行升级

解析方法：使用mybatis的scriptRunner执行

# 问题汇总


# sqlite表设计
**客户端表**
- 客户端id
- 最后一次上线时间
- 创建时间

**客户端关联的订阅过滤器表**
- 客户端id
- 订阅表达式
- 订阅时间
- qos

**收到的消息表**
- 收到的qos等级
- 主题
- 收到的消息id
- 消息来源客户端id
- 消息内容
- 是否已发送PUBACK（qos=1）
- 是否收到PUBREL（qos=2）
- 是否发送PUBCOMP（qos=2）
- 是否完成（qos=1已发送PUBACK、qos=2已发送PUBCOMP）
- 超时时间（取消异步任务的执行时间）

**发送的消息表**
- 收到的qos等级
- 收到的消息id
- 消息来源客户端id
- 发送的qos等级
- 主题
- 发送的消息id
- 消息目的地客户端id
- 消息内容
- 是否收到PUBACK
- 是否收到PUBREC
- 是否收到PUBCOMP
- 超时时间（取消异步任务的执行时间）

**保留消息表（retain message）**
- 消息内容
- 收到的qos等级
- 主题
business

**异步任务表（async job）**
- 任务id
- 业务标识（用于实现具体逻辑）
- 最近一次执行开始时间
- 最近一次执行结束时间
- 最近一次执行结果（SUCCESS FAIL）
- 最近一次执行结果描述
- 下一次执行时间
- 执行次数
- 任务状态（READY EXECUTING FINISH）
- 扩展数据json（先只存放traceId）

**元数据表**
- key
- value
- desc